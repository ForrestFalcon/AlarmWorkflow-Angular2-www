/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v8.8.6231.36137 (NJsonSchema v7.7.6231.35489) (http://NSwag.org)
// </auto-generated>
//----------------------

/** Represents an operation, which was created by analyzing and parsing an incoming alarmfax. */
export class Operation {
    /** Gets/sets the unique Id of this operation. */
    id: number;
    /** Gets/sets the guid of this operation that is globally unique. */
    operationGuid: string;
    /** Gets/sets the timestamp of when the operation materialized ("incoming" timestamp).
For the actual alarm timestamp, use the property . */
    timestampIncome: Date;
    /** Gets/sets the date and time of the actual alarm. */
    timestamp: Date;
    /** Gets or sets the Einsatznummer object. */
    operationNumber: string;
    /** Gets or sets the Mitteiler object. */
    messenger: string;
    /** Gets/sets the priority of this operation. */
    priority: string;
    /** Gets/sets the "Einsatzort" (place of action).
Usually this location contains the destination spot. */
    einsatzort: PropertyLocation;
    /** Gets/sets the "Zielort" (destination location).
This is usually empty. */
    zielort: PropertyLocation;
    /** Gets/sets the comment text. Usually this contains the result from the "Bemerkung" or "Hinweis" (etc.)-sections. */
    comment: string;
    /** Gets the Meldebild object. */
    picture: string;
    /** Gets the Einsatzplan object. */
    operationPlan: string;
    /** Gets/sets the keywords for this operation. */
    keywords: OperationKeywords;
    /** Gets/sets the list of all resources requested by the call center. */
    resources: OperationResourceCollection;
    /** Gets/sets the custom data for this operation. */
    customData: { [key: string] : any; };
    /** Gets/sets whether or not this operation is acknowledged, that means that this operation is no longer necessary to be displayed in the UI as "fresh".
If this is set to "false" then this operation will always been shown in the UI. By default, an operation is set to "acknowledged"
either if the user manually acknowledges it or after a defined timespan (usually 8 hours). */
    isAcknowledged: boolean;
    /** Gets/sets the loop information that is associated with this operation. */
    loops: OperationLoopCollection;
    /** Defines the default timespan after which new operations/alarms are set to "acknowledged". See "IsAcknowledged"-property for further information. */
    defaultAcknowledgingTimespan: string;
    constructor(data?: any) {
        if (data !== undefined) {
            this.id = data["Id"] !== undefined ? data["Id"] : null;
            this.operationGuid = data["OperationGuid"] !== undefined ? data["OperationGuid"] : null;
            this.timestampIncome = data["TimestampIncome"] ? new Date(data["TimestampIncome"].toString()) : null;
            this.timestamp = data["Timestamp"] ? new Date(data["Timestamp"].toString()) : null;
            this.operationNumber = data["OperationNumber"] !== undefined ? data["OperationNumber"] : null;
            this.messenger = data["Messenger"] !== undefined ? data["Messenger"] : null;
            this.priority = data["Priority"] !== undefined ? data["Priority"] : null;
            this.einsatzort = data["Einsatzort"] ? PropertyLocation.fromJS(data["Einsatzort"]) : null;
            this.zielort = data["Zielort"] ? PropertyLocation.fromJS(data["Zielort"]) : null;
            this.comment = data["Comment"] !== undefined ? data["Comment"] : null;
            this.picture = data["Picture"] !== undefined ? data["Picture"] : null;
            this.operationPlan = data["OperationPlan"] !== undefined ? data["OperationPlan"] : null;
            this.keywords = data["Keywords"] ? OperationKeywords.fromJS(data["Keywords"]) : null;
            this.resources = data["Resources"] ? OperationResourceCollection.fromJS(data["Resources"]) : null;
            if (data["CustomData"]) {
                this.customData = {};
                for (let key in data["CustomData"]) {
                    if (data["CustomData"].hasOwnProperty(key))
                        this.customData[key] = data["CustomData"][key] !== undefined ? data["CustomData"][key] : null;
                }
            }
            this.isAcknowledged = data["IsAcknowledged"] !== undefined ? data["IsAcknowledged"] : null;
            this.loops = data["Loops"] ? OperationLoopCollection.fromJS(data["Loops"]) : null;
            this.defaultAcknowledgingTimespan = data["DefaultAcknowledgingTimespan"] !== undefined ? data["DefaultAcknowledgingTimespan"] : null;
        }
    }

    static fromJS(data: any): Operation {
        return new Operation(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Id"] = this.id !== undefined ? this.id : null;
        data["OperationGuid"] = this.operationGuid !== undefined ? this.operationGuid : null;
        data["TimestampIncome"] = this.timestampIncome ? this.timestampIncome.toISOString() : null;
        data["Timestamp"] = this.timestamp ? this.timestamp.toISOString() : null;
        data["OperationNumber"] = this.operationNumber !== undefined ? this.operationNumber : null;
        data["Messenger"] = this.messenger !== undefined ? this.messenger : null;
        data["Priority"] = this.priority !== undefined ? this.priority : null;
        data["Einsatzort"] = this.einsatzort ? this.einsatzort.toJS() : null;
        data["Zielort"] = this.zielort ? this.zielort.toJS() : null;
        data["Comment"] = this.comment !== undefined ? this.comment : null;
        data["Picture"] = this.picture !== undefined ? this.picture : null;
        data["OperationPlan"] = this.operationPlan !== undefined ? this.operationPlan : null;
        data["Keywords"] = this.keywords ? this.keywords.toJS() : null;
        data["Resources"] = this.resources ? this.resources.toJS() : null;
        if (this.customData) {
            data["CustomData"] = {};
            for (let key in this.customData) {
                if (this.customData.hasOwnProperty(key))
                    data["CustomData"][key] = this.customData[key] !== undefined ? this.customData[key] : null;
            }
        }
        data["IsAcknowledged"] = this.isAcknowledged !== undefined ? this.isAcknowledged : null;
        data["Loops"] = this.loops ? this.loops.toJS() : null;
        data["DefaultAcknowledgingTimespan"] = this.defaultAcknowledgingTimespan !== undefined ? this.defaultAcknowledgingTimespan : null;
        return data;
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new Operation(JSON.parse(json));
    }

    getCssClass() {
      var c = 'brand';
      var keyword = this.keywords.emergencyKeyword.toLowerCase();

      if(keyword.startsWith("vu")
        || keyword.startsWith("thl"))
        c = 'thl';
      else if(keyword.startsWith("gefahrgut"))
        c = 'gefahrgut';

      return c;
    }
}

/** Defines the location of a property. */
export class PropertyLocation {
    /** Gets/sets the location name. */
    location: string;
    /** Gets/sets the zip code of the city. */
    zipCode: string;
    /** Gets/sets the city name. */
    city: string;
    /** Gets/sets the street. May contain the street number. */
    street: string;
    /** Gets/sets the street number. May be contained within the street. */
    streetNumber: string;
    /** Gets/sets a description of the "Intersection" (if provided by alarmsource). */
    intersection: string;
    /** Gets/sets the latitude of the location (if provided by alarmsource). */
    geoLatitude: number;
    /** Gets/sets the longitude of the location (if provided by alarmsource). */
    geoLongitude: number;
    /** Gets the latitude of the location in a string with a "." */
    geoLatitudeString: string;
    /** Gets the longitude of the location in a string with a "."
             */
    geoLongitudeString: string;
    /** Gets/sets the name of the property (company, site, house etc.). */
    property: string;
    /** Gets the latitude and longitude as a semicolon-separated string,
or sets the values of  and  from a semicolon-separated string. */
    geoLatLng: string;
    /** Gets whether or not this instance represents a meaningful geographic location.
This takes only ZipCode, City and Street into account.  */
    isMeaningful: boolean;
    /** Gets whether or not there are meaningful values for the geo coordinates (latitude and longitude) defined. */
    hasGeoCoordinates: boolean;
    constructor(data?: any) {
        if (data !== undefined) {
            this.location = data["Location"] !== undefined ? data["Location"] : null;
            this.zipCode = data["ZipCode"] !== undefined ? data["ZipCode"] : null;
            this.city = data["City"] !== undefined ? data["City"] : null;
            this.street = data["Street"] !== undefined ? data["Street"] : null;
            this.streetNumber = data["StreetNumber"] !== undefined ? data["StreetNumber"] : null;
            this.intersection = data["Intersection"] !== undefined ? data["Intersection"] : null;
            this.geoLatitude = data["GeoLatitude"] !== undefined ? data["GeoLatitude"] : null;
            this.geoLongitude = data["GeoLongitude"] !== undefined ? data["GeoLongitude"] : null;
            this.geoLatitudeString = data["GeoLatitudeString"] !== undefined ? data["GeoLatitudeString"] : null;
            this.geoLongitudeString = data["GeoLongitudeString"] !== undefined ? data["GeoLongitudeString"] : null;
            this.property = data["Property"] !== undefined ? data["Property"] : null;
            this.geoLatLng = data["GeoLatLng"] !== undefined ? data["GeoLatLng"] : null;
            this.isMeaningful = data["IsMeaningful"] !== undefined ? data["IsMeaningful"] : null;
            this.hasGeoCoordinates = data["HasGeoCoordinates"] !== undefined ? data["HasGeoCoordinates"] : null;
        }
    }

    static fromJS(data: any): PropertyLocation {
        return new PropertyLocation(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Location"] = this.location !== undefined ? this.location : null;
        data["ZipCode"] = this.zipCode !== undefined ? this.zipCode : null;
        data["City"] = this.city !== undefined ? this.city : null;
        data["Street"] = this.street !== undefined ? this.street : null;
        data["StreetNumber"] = this.streetNumber !== undefined ? this.streetNumber : null;
        data["Intersection"] = this.intersection !== undefined ? this.intersection : null;
        data["GeoLatitude"] = this.geoLatitude !== undefined ? this.geoLatitude : null;
        data["GeoLongitude"] = this.geoLongitude !== undefined ? this.geoLongitude : null;
        data["GeoLatitudeString"] = this.geoLatitudeString !== undefined ? this.geoLatitudeString : null;
        data["GeoLongitudeString"] = this.geoLongitudeString !== undefined ? this.geoLongitudeString : null;
        data["Property"] = this.property !== undefined ? this.property : null;
        data["GeoLatLng"] = this.geoLatLng !== undefined ? this.geoLatLng : null;
        data["IsMeaningful"] = this.isMeaningful !== undefined ? this.isMeaningful : null;
        data["HasGeoCoordinates"] = this.hasGeoCoordinates !== undefined ? this.hasGeoCoordinates : null;
        return data;
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new PropertyLocation(JSON.parse(json));
    }
}

/** Contains the keywords ("stichwörter") for an operation. */
export class OperationKeywords {
    /** Gets/sets the "Stichwort" (generic keyword), direct or equivalent. */
    keyword: string;
    /** Gets/sets the B/R/S/T/etc. keyword for sources that don't distinguish between them. */
    emergencyKeyword: string;
    /** Gets/sets the "Stichwort B" (specific keyword), direct or equivalent. */
    b: string;
    /** Gets/sets the "Stichwort R" (specific keyword), direct or equivalent. */
    r: string;
    /** Gets/sets the "Stichwort S" (specific keyword), direct or equivalent. */
    s: string;
    /** Gets/sets the "Stichwort T" (specific keyword), direct or equivalent. */
    t: string;
    constructor(data?: any) {
        if (data !== undefined) {
            this.keyword = data["Keyword"] !== undefined ? data["Keyword"] : null;
            this.emergencyKeyword = data["EmergencyKeyword"] !== undefined ? data["EmergencyKeyword"] : null;
            this.b = data["B"] !== undefined ? data["B"] : null;
            this.r = data["R"] !== undefined ? data["R"] : null;
            this.s = data["S"] !== undefined ? data["S"] : null;
            this.t = data["T"] !== undefined ? data["T"] : null;
        }
    }

    static fromJS(data: any): OperationKeywords {
        return new OperationKeywords(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Keyword"] = this.keyword !== undefined ? this.keyword : null;
        data["EmergencyKeyword"] = this.emergencyKeyword !== undefined ? this.emergencyKeyword : null;
        data["B"] = this.b !== undefined ? this.b : null;
        data["R"] = this.r !== undefined ? this.r : null;
        data["S"] = this.s !== undefined ? this.s : null;
        data["T"] = this.t !== undefined ? this.t : null;
        return data;
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new OperationKeywords(JSON.parse(json));
    }
}

/** Represents a collection that holds many s and is displayable as a string. */
export class OperationResourceCollection {
    /** Defines the format string that is used to format this instance as a single line. */
    singleLineFormatString: string;
    /** Defines the format string that is used to format this instance using three lines per resource. */
    threeLinesFormatString: string;
    constructor(data?: any) {
        if (data !== undefined) {
            this.singleLineFormatString = data["SingleLineFormatString"] !== undefined ? data["SingleLineFormatString"] : null;
            this.threeLinesFormatString = data["ThreeLinesFormatString"] !== undefined ? data["ThreeLinesFormatString"] : null;
        }
    }

    static fromJS(data: any): OperationResourceCollection {
        return new OperationResourceCollection(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["SingleLineFormatString"] = this.singleLineFormatString !== undefined ? this.singleLineFormatString : null;
        data["ThreeLinesFormatString"] = this.threeLinesFormatString !== undefined ? this.threeLinesFormatString : null;
        return data;
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new OperationResourceCollection(JSON.parse(json));
    }
}

/** Represents a resource, which was was requested by the call center. */
export class OperationResource {
    /** Gets/sets the name of the resource. Usually this represents a vehicle. */
    fullName: string;
    /** Gets/sets the timestamp of the request. May be empty. */
    timestamp: string;
    /** Gets/sets any equipment that is explicitely requested. May be empty. */
    requestedEquipment: string[];
    constructor(data?: any) {
        if (data !== undefined) {
            this.fullName = data["FullName"] !== undefined ? data["FullName"] : null;
            this.timestamp = data["Timestamp"] !== undefined ? data["Timestamp"] : null;
            if (data["RequestedEquipment"] && data["RequestedEquipment"].constructor === Array) {
                this.requestedEquipment = [];
                for (let item of data["RequestedEquipment"])
                    this.requestedEquipment.push(item);
            }
        }
    }

    static fromJS(data: any): OperationResource {
        return new OperationResource(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["FullName"] = this.fullName !== undefined ? this.fullName : null;
        data["Timestamp"] = this.timestamp !== undefined ? this.timestamp : null;
        if (this.requestedEquipment && this.requestedEquipment.constructor === Array) {
            data["RequestedEquipment"] = [];
            for (let item of this.requestedEquipment)
                data["RequestedEquipment"].push(item);
        }
        return data;
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new OperationResource(JSON.parse(json));
    }
}

/** Represents a strongly-typed collection that holds loop information from an Operation. */
export class OperationLoopCollection {
    /** Defines the separator used when joining loops together to a string. */
    loopSeparator: string;
    constructor(data?: any) {
        if (data !== undefined) {
            this.loopSeparator = data["LoopSeparator"] !== undefined ? data["LoopSeparator"] : null;
        }
    }

    static fromJS(data: any): OperationLoopCollection {
        return new OperationLoopCollection(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["LoopSeparator"] = this.loopSeparator !== undefined ? this.loopSeparator : null;
        return data;
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new OperationLoopCollection(JSON.parse(json));
    }
}
